/**
 * ThemeMapper - Maps CSS variables to placeholder hex colors for Shiki
 *
 * Shiki requires valid hex colors in themes, but we want to use CSS variables
 * so colors can be defined by the active Obsidian theme.
 *
 * Solution:
 * 1. Replace CSS variables with unique placeholder hex colors (#000000, #000001, etc.)
 * 2. Pass theme with placeholders to Shiki
 * 3. After Shiki generates HTML, replace placeholders back with CSS variables
 *
 * Based on: https://github.com/mProjectsCode/obsidian-shiki-plugin (MIT License)
 */

import { type ThemeRegistration } from "shiki";
import { OBSIDIAN_THEME } from "./ObsidianTheme";

export const OBSIDIAN_THEME_IDENTIFIER = "obsidian-theme";

export class ThemeMapper {
  private mapping = new Map<string, string>();
  private counter = 0;

  /**
   * Maps a CSS variable to a unique placeholder hex color.
   * If already mapped, returns the existing placeholder.
   *
   * @param cssVar - The CSS variable (e.g., "var(--shiki-code-keyword)")
   * @returns A placeholder hex color (e.g., "#000001")
   */
  mapColor(cssVar: string): string {
    // If it's already a hex color or not a CSS variable, return as-is
    if (!cssVar.startsWith("var(")) {
      return cssVar;
    }

    // Return existing mapping if present
    if (this.mapping.has(cssVar)) {
      return this.mapping.get(cssVar)!;
    }

    // Create new placeholder hex color
    const placeholder = `#${this.counter.toString(16).padStart(6, "0").toUpperCase()}`;
    this.counter++;
    this.mapping.set(cssVar, placeholder);
    return placeholder;
  }

  /**
   * Generates a theme with placeholder hex colors for Shiki.
   * CSS variables are replaced with unique hex placeholders.
   *
   * @returns ThemeRegistration with placeholder colors
   */
  getMappedTheme(): ThemeRegistration {
    return {
      displayName: OBSIDIAN_THEME.displayName,
      name: OBSIDIAN_THEME.name,
      semanticHighlighting: OBSIDIAN_THEME.semanticHighlighting,
      type: OBSIDIAN_THEME.type,
      colors: Object.fromEntries(
        Object.entries(OBSIDIAN_THEME.colors).map(([key, value]) => [
          key,
          this.mapColor(value),
        ])
      ),
      tokenColors: OBSIDIAN_THEME.tokenColors.map((token) => ({
        ...token,
        settings: {
          ...token.settings,
          foreground: token.settings.foreground
            ? this.mapColor(token.settings.foreground)
            : undefined,
        },
      })),
    };
  }

  /**
   * Post-processing: replaces placeholder hex colors with CSS variables in HTML.
   *
   * @param html - The HTML generated by Shiki with placeholder colors
   * @returns HTML with CSS variables instead of placeholders
   */
  fixHTML(html: string): string {
    let result = html;
    for (const [cssVar, placeholder] of this.mapping) {
      // Replace both uppercase and lowercase versions
      result = result.replaceAll(placeholder, cssVar);
      result = result.replaceAll(placeholder.toLowerCase(), cssVar);
    }
    return result;
  }

  /**
   * Resets the mapping. Call this when reinitializing the highlighter.
   */
  reset(): void {
    this.mapping.clear();
    this.counter = 0;
  }

  /**
   * Returns the number of mapped colors.
   */
  getMappingCount(): number {
    return this.mapping.size;
  }

  /**
   * Convert a placeholder hex color back to CSS variable.
   * Used for token-based rendering (Edit mode).
   *
   * @param placeholder - The placeholder hex color (e.g., "#000001")
   * @returns The CSS variable (e.g., "var(--shiki-code-keyword)") or undefined if not found
   */
  placeholderToCssVar(placeholder: string | undefined): string | undefined {
    if (!placeholder) return undefined;

    // Normalize to uppercase for comparison
    const normalized = placeholder.toUpperCase();

    for (const [cssVar, hex] of this.mapping) {
      if (hex === normalized) {
        return cssVar;
      }
    }

    // Return undefined if not found - caller should handle fallback
    return undefined;
  }
}
